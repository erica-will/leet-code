
// 用例子說明跳過的數字為什麼不會被漏掉
// nums = [1, 2, 3, 4, 6], k = 7
// 排序後：[1, 2, 3, 4, 6]
// i = 0, j = 4 → 1 + 6 = 7 ✅ 找到一對，i++, j-- → i=1, j=3
// i = 1, j = 3 → 2 + 4 = 6 ❌ 太小了，i++ → i=2
// i = 2, j = 3 → 3 + 4 = 7 ✅ 找到第二對，i++, j-- → i=3, j=2 → 結束
// 這裡當我們在 2 + 4 = 6 太小時，直接把 i 往右移到 3（也就是數字 3），這樣我們才有可能加上 4 剛好等於 7。

// 如果你懷疑：剛剛的 2 被跳過了，那它還有機會跟別人組成 7 嗎？

// → 答案是不可能。為什麼？

// 因為 2 + 4 = 6 已經是 2 和剩下最大的值 4 加起來的結果了，再怎麼樣都不會更大。 而 nums 是排序過的，右邊的都比 4 還小，跟 2 加起來只會更小。 所以 2 不可能再和其他數組成 7，因此它可以安全地被跳過。
function maxOperations(nums: number[], k: number): number {
    nums.sort((a, b) => a - b);
    let ans = 0;
    let i = 0, j = nums.length - 1;
    while (i < j) {
        let temp = nums[i] + nums[j];
        if (temp === k) {
            i++;
            j--;
            ans++;
        } else if (temp > k) {
            j--;
        } else {
            i++;
        }
    }
    return ans;
};